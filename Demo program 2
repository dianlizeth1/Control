
    	this.leftMotor.forward();
   		this.rightMotor.forward();
   		int baseVelocity=20;
   		double omega=0;
   		double v=10;
   		
   			// Assuming this.encoderLeft is an instance of IPerception.EncoderSensor

   			// Get the encoder measurement
   			IPerception.AngleDifferenceMeasurement angleMeasurementLeft = this.encoderLeft.getEncoderMeasurement();
   			
   			IPerception.AngleDifferenceMeasurement angleMeasurementRight = this.encoderRight.getEncoderMeasurement();

   	
   			    double r = 0.028; // m
   			    double d = 0.114; //m

   			    double omegaRightWheel = angleMeasurementRight.getAngleSum() / 0.1;
   			    double omegaLeftWheel = angleMeasurementLeft.getAngleSum() / 0.1;
   			    double vRight = r * omegaRightWheel;
   			    double vLeft = r * omegaLeftWheel;

   			    double desiredVRight; // Declare outside the if block
   			    double desiredVLeft; // Declare outside the if block
   			    
   			   double desiredVRightOmega; // Declare outside the if block
			   double desiredVLeftOmega;

   			  
   			        desiredVRight = 2 * v - vLeft;
   			        desiredVLeft = 2 * v - vRight;
   			    
   			        // Equations for Angular velocity of the robot when omega is not 0
   			        desiredVRightOmega = d * omega + vLeft;
   			        desiredVLeftOmega= -d * omega +vRight;
   			    

   			    // ... (other code)

   			    // PID Constants and control for the right wheel
   			    double kpRight = 0.09;
   			    double kiRight = 0.06;
   			    double kdRight = 0.08;

   			    double errorRight = desiredVRight - vRight;
   			    integralRight += errorRight;
   			    double derivativeRight = errorRight - previousErrorRight;
   			    double correctionRight = kpRight * errorRight + kiRight * integralRight + kdRight * derivativeRight;
   			    previousErrorRight = errorRight;

   			    // PID Constants and control for the left wheel
   			    double kpLeft = 0.08;
   			    double kiLeft = 0.06;
   			    double kdLeft = 0.08;

   			    double errorLeft = desiredVLeft -vLeft;
   			    integralLeft += errorLeft;
   			    double derivativeLeft = errorLeft - previousErrorLeft;
   			    double correctionLeft = kpLeft * errorLeft + kiLeft * integralLeft + kdLeft * derivativeLeft;
   			    previousErrorLeft = errorLeft;

   			    // Calculate motor speeds
   			    double motorspeedLeft =  (baseVelocity +correctionLeft);
   			    double motorspeedRight = baseVelocity + correctionRight;
   			    
   			//--------------------------------------------------------------------------------------  
   			// PID Constants and control for the right wheel when implementing omega
   			 double kpRightOmega = 0.08;
   			 double kiRightOmega = 0.06;
   			 double kdRightOmega = 0.08;

   			 double errorRightOmega = desiredVRightOmega - vRight;
   			 integralRightOmega += errorRightOmega;
   			 double derivativeRightOmega = errorRightOmega - previousErrorRightOmega;
   			 double correctionRightOmega = kpRightOmega * errorRight + kiRightOmega * integralRightOmega + kdRightOmega * derivativeRightOmega;
   			 previousErrorRightOmega = errorRightOmega;
   			 
   			 // PID Constants and control for the left wheel when implementing omega
   			 double kpLeftOmega = 0.08;
   			 double kiLeftOmega = 0.06;
   			 double kdLeftOmega = 0.08;

   			 double errorLeftOmega = desiredVLeftOmega -vLeft;
   			 integralLeftOmega += errorLeftOmega;
   			 double derivativeLeftOmega = errorLeftOmega - previousErrorLeftOmega;
   			 double correctionLeftOmega = kpLeftOmega * errorLeftOmega + kiLeftOmega * integralLeftOmega + kdLeftOmega * derivativeLeftOmega;
   			 previousErrorLeftOmega = errorLeftOmega;

   			 // Calculate motor speeds when implementing omega
   			double motorspeedLeftOmega = -(baseVelocity + correctionLeftOmega);
   			double motorspeedRightOmega = baseVelocity + correctionRightOmega;
   			 
   			 this.leftMotor.setPower((int) motorspeedLeftOmega);
			 this.rightMotor.setPower((int) motorspeedRightOmega);
			 
			//--------------------------------------------------------------------------------------  	    
   			 double kpMotors = 1.2;
			 double kiMotors = 1.00;
			 double kdMotors = 1.2;
   			    
			 
			 if (omega == 0) {
				 
				 double errorMotors =vLeft-vRight;
				 integralMotors += errorMotors;
		   			double derivativeMotors = errorMotors - previousErrorMotors;
		   			double correctionMotors = kpMotors * errorMotors + kiMotors * integralMotors + kdMotors * derivativeMotors;
		   			previousErrorMotors = errorMotors;
		   			double motorspeedLeftF = (motorspeedLeft -correctionMotors);
		   		    double motorspeedRightF = (motorspeedRight +correctionMotors);
		   		    
		   		    this.leftMotor.setPower((int) motorspeedLeftF);
				    this.rightMotor.setPower((int) motorspeedRightF);
				    LCD.drawString("vRight: " + vRight, 0, 2);
	   			    LCD.drawString("vLeft: " + vLeft, 0, 3);
//	   			    LCD.drawString("Mr: " + motorspeedRightF, 0, 3);
//	   			    LCD.drawString("Ml: " + motorspeedLeftF,0,4);
			       
			    } else {
			        // Equations for Angular velocity of the robot when omega is not 0
			    double errorMotors = vLeft+vRight;
			    integralMotors += errorMotors;
	   			double derivativeMotors = errorMotors - previousErrorMotors;
	   			double correctionMotors = kpMotors * errorMotors + kiMotors * integralMotors + kdMotors * derivativeMotors;
	   			previousErrorMotors = errorMotors;
	   			double motorspeedLeftF = (motorspeedLeftOmega -correctionMotors);
	   		    double motorspeedRightF = (motorspeedRightOmega +correctionMotors);
	   		    this.leftMotor.setPower((int) motorspeedLeftF);
			    this.rightMotor.setPower((int) motorspeedRightF);
			    
			    LCD.drawString("vRight: " + vRight, 0, 2);
   			    LCD.drawString("vLeft: " + vLeft, 0, 3);
//   			    LCD.drawString("Mr: " + motorspeedRightF, 0, 3);
//   			    LCD.drawString("Ml: " + motorspeedLeftF,0,4);
//   			    LCD.drawString("MR: " + motorspeedRight,0,6);
//   			    LCD.drawString("ML: " + motorspeedLeft,0,7);
   			 
   			 	double targetAngle = 90.0;
   			 	double anglephi = navigation.getPose().getHeading() * 180.0 / Math.PI;
		    
   			 			if (anglephi >= targetAngle) {
   			 					this.leftMotor.stop();
   			 					this.rightMotor.stop();
   			 			}
   			 		
			    }}
