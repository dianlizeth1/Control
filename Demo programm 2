 private void exec_LINECTRL_ALGO() {
    	
//    	double omega = 0; // Set your desired angular velocity
//      double v = 0; // Set your desired linear velocity
        double x=navigation.getPose().getX()*100;
        double targetCm= 120;
        double targetCm2= 150;
        // Call the drive method with the desired velocities
        drive(10,0);
        
        double targetAngle = 90.0;
		 double anglephi = navigation.getPose().getHeading() * 180.0 / Math.PI;
    
		 			if (x >= targetCm) {
//		 					this.leftMotor.stop();
//		 					this.rightMotor.stop();	
		 					stop();
		 					 drive(0,30);
		 			}	
		 			
		 			if (anglephi >= targetAngle) {
//	 					this.leftMotor.stop();
//	 					this.rightMotor.stop();	
		 				stop();
	 					 drive(5,0);
		 			}	 	
		 			if (x >= targetCm2) {
//	 					this.leftMotor.stop();
//	 					this.rightMotor.stop();	
		 				stop();
	 					
		 			}	 	
    			
    }

//    // New function providing values to drive
//    private void customFunctionDiana() {
//    	double omega=30;
//   		double v=0;
//   		
//   		drive(v,omega);
//    }

    // Example usage:
    // Call this function wherever appropriate in your code, providing necessary parameters
    	
   			
//   			
//   		  if (correctionMotors <= -100 || correctionMotors >= 100) {
//       	    // Set both motor speeds to baseVelocity
//       	    integralMotors = 0;
//       	}
////   			
////   		// Calculate motor speeds
   		  
   			    

   			    // Set motor powers
   			    

   			    // Display information
   			    
		    	
	private void stop(){
		this.leftMotor.stop();
		this.rightMotor.stop();
		
		 leftMotorPower = 0;
			rightMotorPower = 0;
			
			  integralRight = 0; // Initialize integral for the right wheel outside the loop or method
			  previousErrorRight = 0; // Initialize appropriately for the right wheel
			  integralLeft = 0; // Initialize integral for the left wheel outside the loop or method
			  previousErrorLeft = 0; // Initialize appropriately for the left wheel
			 integral=0;
			 previousError=0;
			
			
			 integralMotors=0;
			 previousErrorMotors=0;

			 integralRightOmega = 0.0;
			 previousErrorRightOmega = 0.0;
			
			 integralLeftOmega = 0.0;
			 previousErrorLeftOmega = 0.0;
			 errorMotors=0;
		
		
	}

		
    /**
     * calculates the left and right angle speed of the both motors with given velocity 
     * and angle velocity of the robot
     * @param v velocity of the robot
     * @param omega angle velocity of the robot
     */
	private void drive(double v, double omega) {
	    // ... (other variable declarations)
		this.leftMotor.forward();
   		this.rightMotor.forward();
   		int baseVelocity=20;
   		
   			// Assuming this.encoderLeft is an instance of IPerception.EncoderSensor

   			// Get the encoder measurement
   			IPerception.AngleDifferenceMeasurement angleMeasurementLeft = this.encoderLeft.getEncoderMeasurement();
   			
   			IPerception.AngleDifferenceMeasurement angleMeasurementRight = this.encoderRight.getEncoderMeasurement();

   	
   			    double r = 0.028; // m
   			    double d = 0.114; //m

   			    double omegaRightWheel = angleMeasurementRight.getAngleSum() / 0.1;
   			    double omegaLeftWheel = angleMeasurementLeft.getAngleSum() / 0.1;
   			    double vRight = r * omegaRightWheel;
   			    double vLeft = r * omegaLeftWheel;

   			    double desiredVRight; // Declare outside the if block
   			    double desiredVLeft; // Declare outside the if block
   			    
   			   double desiredVRightOmega; // Declare outside the if block
			   double desiredVLeftOmega;

   			  
   			        desiredVRight = 2 * v - vLeft;
   			        desiredVLeft = 2 * v - vRight;
   			    
   			        // Equations for Angular velocity of the robot when omega is not 0
   			        desiredVRightOmega = d * omega + vLeft;
   			        desiredVLeftOmega= -d * omega +vRight;
   			    

   			    // ... (other code)

   			    // PID Constants and control for the right wheel
   			    double kpRight = 0.09;
   			    double kiRight = 0.06;
   			    double kdRight = 0.08;

   			    double errorRight = desiredVRight - vRight;
   			    integralRight += errorRight;
   			    double derivativeRight = errorRight - previousErrorRight;
   			    double correctionRight = kpRight * errorRight + kiRight * integralRight + kdRight * derivativeRight;
   			    previousErrorRight = errorRight;

   			    // PID Constants and control for the left wheel
   			    double kpLeft = 0.08;
   			    double kiLeft = 0.06;
   			    double kdLeft = 0.08;

   			    double errorLeft = desiredVLeft -vLeft;
   			    integralLeft += errorLeft;
   			    double derivativeLeft = errorLeft - previousErrorLeft;
   			    double correctionLeft = kpLeft * errorLeft + kiLeft * integralLeft + kdLeft * derivativeLeft;
   			    previousErrorLeft = errorLeft;

   			    // Calculate motor speeds
   			    double motorspeedLeft =  (baseVelocity +correctionLeft);
   			    double motorspeedRight = baseVelocity + correctionRight;
   			    
   			//--------------------------------------------------------------------------------------  
   			// PID Constants and control for the right wheel when implementing omega
   			 double kpRightOmega = 0.08;
   			 double kiRightOmega = 0.06;
   			 double kdRightOmega = 0.08;

   			 double errorRightOmega = desiredVRightOmega - vRight;
   			 integralRightOmega += errorRightOmega;
   			 double derivativeRightOmega = errorRightOmega - previousErrorRightOmega;
   			 double correctionRightOmega = kpRightOmega * errorRight + kiRightOmega * integralRightOmega + kdRightOmega * derivativeRightOmega;
   			 previousErrorRightOmega = errorRightOmega;
   			 
   			 // PID Constants and control for the left wheel when implementing omega
   			 double kpLeftOmega = 0.08;
   			 double kiLeftOmega = 0.06;
   			 double kdLeftOmega = 0.08;

   			 double errorLeftOmega = desiredVLeftOmega -vLeft;
   			 integralLeftOmega += errorLeftOmega;
   			 double derivativeLeftOmega = errorLeftOmega - previousErrorLeftOmega;
   			 double correctionLeftOmega = kpLeftOmega * errorLeftOmega + kiLeftOmega * integralLeftOmega + kdLeftOmega * derivativeLeftOmega;
   			 previousErrorLeftOmega = errorLeftOmega;

   			 // Calculate motor speeds when implementing omega
   			double motorspeedLeftOmega = -(baseVelocity + correctionLeftOmega);
   			double motorspeedRightOmega = baseVelocity + correctionRightOmega;
   			 
   			 this.leftMotor.setPower((int) motorspeedLeftOmega);
			 this.rightMotor.setPower((int) motorspeedRightOmega);
			 
			//--------------------------------------------------------------------------------------  	    
   			 double kpMotors = 1.2;
			 double kiMotors = 1.00;
			 double kdMotors = 1.2;
   			    
			 
			 if (omega == 0) {
				 
				 double errorMotors =vLeft-vRight;
				 integralMotors += errorMotors;
		   			double derivativeMotors = errorMotors - previousErrorMotors;
		   			double correctionMotors = kpMotors * errorMotors + kiMotors * integralMotors + kdMotors * derivativeMotors;
		   			previousErrorMotors = errorMotors;
		   			double motorspeedLeftF = (motorspeedLeft -correctionMotors);
		   		    double motorspeedRightF = (motorspeedRight +correctionMotors);
		   		    
		   		    this.leftMotor.setPower((int) motorspeedLeftF);
				    this.rightMotor.setPower((int) motorspeedRightF);
				    LCD.drawString("vRight: " + vRight, 0, 2);
	   			    LCD.drawString("vLeft: " + vLeft, 0, 3);
//	   			    LCD.drawString("Mr: " + motorspeedRightF, 0, 3);
//	   			    LCD.drawString("Ml: " + motorspeedLeftF,0,4);
	   			    
			       
			    } else {
			        // Equations for Angular velocity of the robot when omega is not 0
			    double errorMotors = vLeft+vRight;
			    integralMotors += errorMotors;
	   			double derivativeMotors = errorMotors - previousErrorMotors;
	   			double correctionMotors = kpMotors * errorMotors + kiMotors * integralMotors + kdMotors * derivativeMotors;
	   			previousErrorMotors = errorMotors;
	   			double motorspeedLeftF = (motorspeedLeftOmega -correctionMotors);
	   		    double motorspeedRightF = (motorspeedRightOmega +correctionMotors);
	   		    this.leftMotor.setPower((int) motorspeedLeftF);
			    this.rightMotor.setPower((int) motorspeedRightF);
			    
			    LCD.drawString("vRight: " + vRight, 0, 2);
   			    LCD.drawString("vLeft: " + vLeft, 0, 3);
//   			    LCD.drawString("Mr: " + motorspeedRightF, 0, 3);
//   			    LCD.drawString("Ml: " + motorspeedLeftF,0,4);
//   			    LCD.drawString("MR: " + motorspeedRight,0,6);
//   			    LCD.drawString("ML: " + motorspeedLeft,0,7);
   			 
   			 	
   			 			}
   			 		
					}
			    }
