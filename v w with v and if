private void drive(double v, double omega, double baseVelocity) {
	    // ... (other variable declarations)

	    // You may want to remove this line if you intend to use the original value of omega

	    double integralRight = 0; // Initialize integral for the right wheel outside the loop or method
	    double previousErrorRight = 0; // Initialize appropriately for the right wheel
	    double integralLeft = 0; // Initialize integral for the left wheel outside the loop or method
	    double previousErrorLeft = 0; // Initialize appropriately for the left wheel

	    double r = 2.5; // cm
	    double d = 4;

	    double omegaRightWheel = angleMeasurementRight.getAngleSum() / 0.1;
	    double omegaLeftWheel = angleMeasurementLeft.getAngleSum() / 0.1;
	    double vRight = r * omegaRightWheel;
	    double vLeft = r * omegaLeftWheel;

	    double desiredVRight; // Declare outside the if block
	    double desiredVLeft; // Declare outside the if block

	    if (omega == 0) {
	        desiredVRight = 2 * v - vRight;
	        desiredVLeft = 2 * v - vLeft;
	    } else {
	        // Equations for Angular velocity of the robot when omega is not 0
	        desiredVRight = d * omega + vLeft;
	        desiredVLeft = -(d * omega + vRight);
	    }

	    // ... (other code)

	    // PID Constants and control for the right wheel
	    double kpRight = 0.08;
	    double kiRight = 0.04;
	    double kdRight = 0.08;

	    double errorRight = desiredVRight - vRight;
	    integralRight += errorRight;
	    double derivativeRight = errorRight - previousErrorRight;
	    double correctionRight = kpRight * errorRight + kiRight * integralRight + kdRight * derivativeRight;
	    previousErrorRight = errorRight;

	    // PID Constants and control for the left wheel
	    double kpLeft = 0.08;
	    double kiLeft = 0.04;
	    double kdLeft = 0.08;

	    double errorLeft = desiredVLeft - vLeft;
	    integralLeft += errorLeft;
	    double derivativeLeft = errorLeft - previousErrorLeft;
	    double correctionLeft = kpLeft * errorLeft + kiLeft * integralLeft + kdLeft * derivativeLeft;
	    previousErrorLeft = errorLeft;

	    // Calculate motor speeds
	    double motorspeedLeft = baseVelocity + correctionLeft;
	    double motorspeedRight = baseVelocity + correctionRight;

	    // Set motor powers
	    this.leftMotor.setPower((int) motorspeedLeft);
	    this.rightMotor.setPower((int) motorspeedRight);

	    // Display information
	    LCD.drawString("PowerL: " + leftMotor.getPower(), 0, 5);
	    LCD.drawString("PowerR: " + rightMotor.getPower(), 0, 6);
	}
}
